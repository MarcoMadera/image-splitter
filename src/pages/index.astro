---
import { getImages } from "utils/apiCalls";
import SplitterLayout from "layouts/Splitter.astro";
import SplitterControls from "components/SplitterControls.astro";
import ImagesWrapper from "components/ImagesWrapper.astro";
import SplitterDragAndDrop from "components/SplitterDragAndDrop.astro";

const images = await getImages();
---

<SplitterLayout title="Image Splitter">
  <SplitterControls slot="before-main" />
  <SplitterDragAndDrop />
  <ImagesWrapper
    slot="after-main"
    images={images}
    title="Explore images for splitting"
  />

  <script is:inline define:vars={{ images }} type="module">
    localStorage.setItem("images", JSON.stringify(images));
  </script>

  <script>
    import {
      getSplittedImages,
      downloadSplitImage,
      removeFileExtension,
      getFileNameExtension,
    } from "utils/image-splitter";
    import type { IUploadedImageState } from "types/image-splitter";
    import type { Images } from "types/imagesResponse";
    import { onSwup } from "utils";

    function init() {
      const gridXInput = document.getElementById("gridX") as HTMLInputElement;
      const gridYInput = document.getElementById("gridY") as HTMLInputElement;
      const imageInput = document.getElementById("imageInput");
      const downloadButton = document.getElementById("downloadButton");
      const imageContainer = document.getElementById("imageContainer");
      const imageDropContainer = document.getElementById("imageDropContainer");
      const clearImageButton = document.getElementById("clear-image-btn");
      if (
        !gridXInput ||
        !gridYInput ||
        !imageInput ||
        !downloadButton ||
        !imageDropContainer ||
        !clearImageButton
      ) {
        throw new Error("Element not found");
      }

      let splittedImages: File[] = [];

      const uploadedImageStateHandler = {
        set: <T extends keyof IUploadedImageState>(
          state: IUploadedImageState,
          prop: T,
          value: IUploadedImageState[T]
        ): boolean => {
          state[prop] = value;

          if (prop === "file") {
            const file = value;
            if (file instanceof File) {
              state.name = removeFileExtension(file?.name);
              state.extension = getFileNameExtension(file?.name);
              imageDropContainer?.classList.add("hidden");
              imageContainer?.classList.remove("hidden");
              clearImageButton?.classList.remove("invisible");
            } else if (file) {
              state.name = "image";
              state.extension = "";
              imageDropContainer?.classList.add("hidden");
              imageContainer?.classList.remove("hidden");
              clearImageButton?.classList.remove("invisible");
            }

            if (!file && imageContainer) {
              imageContainer.innerHTML = "";
              state.extension = "";
              imageDropContainer?.classList.remove("hidden");
              imageContainer?.classList.add("hidden");
              clearImageButton?.classList.add("invisible");
            }

            toggleDownloadButton(!file);
          }

          return true;
        },
      };

      const uploadedImageState = new Proxy<IUploadedImageState>(
        { file: null, name: "image", extension: "" },
        uploadedImageStateHandler
      );

      function toggleDownloadButton(disabled?: boolean) {
        if (disabled) {
          downloadButton?.setAttribute("disabled", "");
        } else {
          downloadButton?.removeAttribute("disabled");
        }
      }

      async function handleChangeImage(e: Event) {
        const gridX = Number(gridXInput.value);
        const gridY = Number(gridYInput.value);
        uploadedImageState.file =
          (e.target as HTMLInputElement)?.files?.[0] ?? uploadedImageState.file;

        try {
          splittedImages = await getSplittedImages({
            uploadedImageState,
            gridX,
            gridY,
            target: "#imageContainer",
          });
        } catch (error) {
          // TODO: Implement notification
          uploadedImageState.file = null;
          console.error(error);
        }
      }

      async function handleDownload() {
        const gridX = Number(gridXInput.value);
        const gridY = Number(gridYInput.value);
        const outputName = `${uploadedImageState.name}_grid_${gridX}x${gridY}`;

        try {
          if (gridX <= 0 || gridY <= 0) {
            throw new Error("Grid size cannot be 0");
          }

          await downloadSplitImage({ outputName, splittedImages });
        } catch (error) {
          // TODO: Implement notification
          console.error(error);
        }
      }

      function addButtonChangeListener() {
        const images: Images | null = JSON.parse(
          localStorage.getItem("images") ?? "[]"
        );

        if (images) {
          images.forEach((image) => {
            const button = document.getElementById(image.id);
            if (!button) return;

            button.addEventListener("click", () => {
              const url = new URL(image.urls.regular);

              uploadedImageState.file = url.href;

              handleChangeImage(new Event("change"));
              // TODO: Add loading animation

              // TODO: Remove this and only scroll when upload is done
              window.scrollTo({ top: 0, behavior: "smooth" });
            });
          });
        }
      }

      imageDropContainer.addEventListener("drop", (e) => {
        e.preventDefault();
        const imageId = e.dataTransfer?.getData("text");

        if (imageId) {
          const images: Images | null = JSON.parse(
            localStorage.getItem("images") ?? "[]"
          );

          const image = images?.find((img) => img.id === imageId);

          if (image) {
            const url = new URL(image.urls.regular);

            uploadedImageState.file = url.href;

            handleChangeImage(new Event("change"));
            return;
          } else {
            console.error("Image not found");
          }
        }

        const files = e.dataTransfer?.files;

        if (!files) return;

        if (files.length > 1) {
          console.warn("Only one image can be uploaded at a time");
        }

        const file = files[0];

        if (file) {
          uploadedImageState.file = file;
          handleChangeImage(new Event("change"));
          // TODO: Add loading animation

          // TODO: Remove this and only scroll when upload is done
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      });

      clearImageButton?.addEventListener("click", () => {
        uploadedImageState.file = null;
      });

      gridXInput.addEventListener("change", handleChangeImage);
      gridYInput.addEventListener("change", handleChangeImage);
      imageInput?.addEventListener("change", handleChangeImage);
      downloadButton?.addEventListener("click", handleDownload);
      addButtonChangeListener();
    }

    onSwup("content:replace", init);
  </script>
</SplitterLayout>
