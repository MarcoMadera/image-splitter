---
import { getImages } from "utils/apiCalls";
import SplitterLayout from "layouts/Splitter.astro";
import SplitterControls from "components/SplitterControls.astro";
import ImagesWrapper from "components/ImagesWrapper.tsx";
import SplitterDragAndDrop from "components/SplitterDragAndDrop.astro";
import LoadingError from "components/LoadingError.astro";
import { Icon } from "astro-icon/components";

Astro.response.headers.set("Vercel-CDN-Cache-Control", "max-age=300");
Astro.response.headers.set("CDN-Cache-Control", "max-age=60");

const images = await getImages();
---

<SplitterLayout title="Image Splitter">
  <SplitterControls slot="before-main" />
  <SplitterDragAndDrop />
  <ImagesWrapper
    slot="after-main"
    images={images}
    title="Explore images for splitting"
    client:load
  >
    <LoadingError>There was a problem loading the images</LoadingError>
    <Icon slot="reload-icon" name="mage:reload" size={18} />
  </ImagesWrapper>

  <script is:inline define:vars={{ images }} type="module">
    localStorage.setItem("images", JSON.stringify(images));
  </script>

  <script>
    import {
      getSplittedImages,
      downloadSplitImage,
      removeFileExtension,
      getFileNameExtension,
    } from "utils/image-splitter";
    import type { IUploadedImageState } from "types/image-splitter";
    import type { Images } from "types/imagesResponse";
    import { onSwup } from "utils";

    function init() {
      const gridXInput = document.getElementById("gridX") as HTMLInputElement;
      const gridYInput = document.getElementById("gridY") as HTMLInputElement;
      const imageInput = document.getElementById(
        "imageInput"
      ) as HTMLInputElement;
      const downloadButton = document.getElementById("downloadButton");
      const imageContainer = document.getElementById("imageContainer");
      const imageDropContainer = document.getElementById("imageDropContainer");
      const clearImageButton = document.getElementById("clear-image-btn");
      if (
        !gridXInput ||
        !gridYInput ||
        !imageInput ||
        !downloadButton ||
        !imageDropContainer ||
        !clearImageButton
      ) {
        throw new Error("Element not found");
      }

      let splittedImages: File[] = [];

      const uploadedImageStateHandler = {
        set: <T extends keyof IUploadedImageState>(
          state: IUploadedImageState,
          prop: T,
          value: IUploadedImageState[T]
        ): boolean => {
          state[prop] = value;

          if (prop === "file") {
            const file = value;
            if (file instanceof File) {
              state.name = removeFileExtension(file?.name);
              state.extension = getFileNameExtension(file?.name);
              imageDropContainer?.classList.add("hidden");
              imageContainer?.classList.remove("hidden");
              clearImageButton?.classList.remove("invisible");
            } else if (file) {
              state.extension = "";
              imageInput.value = "";
              imageDropContainer?.classList.add("hidden");
              imageContainer?.classList.remove("hidden");
              clearImageButton?.classList.remove("invisible");
            }

            if (!file && imageContainer) {
              imageContainer.innerHTML = "";
              imageInput.value = "";
              state.name = "image";
              state.extension = "";
              imageDropContainer?.classList.remove("hidden");
              imageContainer?.classList.add("hidden");
              clearImageButton?.classList.add("invisible");
            }

            toggleDownloadButton(!file);
          }

          return true;
        },
      };

      const uploadedImageState = new Proxy<IUploadedImageState>(
        { file: null, name: "image", extension: "", downloadName: "image" },
        uploadedImageStateHandler
      );

      function toggleDownloadButton(disabled?: boolean) {
        if (disabled) {
          downloadButton?.setAttribute("disabled", "");
        } else {
          downloadButton?.removeAttribute("disabled");
        }
      }

      async function handleChangeImage(e: Event) {
        splittedImages = [];
        const gridXInput = document.getElementById(
          "gridX"
        ) as HTMLInputElement | null;
        const gridYInput = document.getElementById(
          "gridY"
        ) as HTMLInputElement | null;

        try {
          if (!gridXInput || !gridYInput) {
            throw new Error("Element not found");
          }

          const gridX = Number(gridXInput.value);
          const gridY = Number(gridYInput.value);
          uploadedImageState.file =
            (e.target as HTMLInputElement)?.files?.[0] ??
            uploadedImageState.file;
          uploadedImageState.downloadName = `${uploadedImageState.name}_grid_${gridX}x${gridY}`;

          splittedImages = await getSplittedImages({
            uploadedImageState,
            gridX,
            gridY,
            target: "#imageContainer",
          });
        } catch (error) {
          // TODO: Implement notification
          if (error instanceof Error) {
            if (error.message === "Grid size cannot be 0") {
              console.error(error);
              return;
            }

            if (error.message === "Grid size too small") {
              console.error(error);
              return;
            }
          }

          uploadedImageState.file = null;
          console.error(error);
        }
      }

      async function handleDownload() {
        const outputName = uploadedImageState.downloadName;

        try {
          await downloadSplitImage({ outputName, splittedImages });
        } catch (error) {
          // TODO: Implement notification
          console.error(error);
        }
      }

      function changeUploadedFile(imageState: IUploadedImageState) {
        uploadedImageState.name = imageState.name;
        uploadedImageState.file = imageState.file;
        uploadedImageState.extension = imageState.extension;
        handleChangeImage(new Event("change"));
        // TODO: Add loading animation

        // TODO: Remove this and only scroll when upload is done
        window.scrollTo({ top: 0, behavior: "smooth" });
      }

      function addButtonChangeListener() {
        window.addEventListener("updateImageState", (e) => {
          const event = e as CustomEvent<IUploadedImageState>;
          changeUploadedFile(event.detail);
        });
      }

      imageDropContainer.addEventListener("drop", (e) => {
        e.preventDefault();
        const imageId = e.dataTransfer?.getData("text");

        if (imageId) {
          const images: Images | null = JSON.parse(
            localStorage.getItem("images") ?? "[]"
          );

          const image = images?.find((img) => img.id === imageId);

          if (image) {
            changeUploadedFile({
              file: image.urls.regular,
              name: image.slug,
              extension: "",
              downloadName: image.slug,
            });
            return;
          } else {
            console.error("Image not found");
          }
        }

        const files = e.dataTransfer?.files;

        if (!files) return;

        if (files.length > 1) {
          console.warn("Only one image can be uploaded at a time");
        }

        const file = files[0];

        if (file) {
          changeUploadedFile({
            file,
            extension: "",
            name: file.name,
            downloadName: file.name,
          });
        }
      });

      clearImageButton?.addEventListener("click", () => {
        uploadedImageState.file = null;
      });

      gridXInput.addEventListener("input", handleChangeImage);
      gridYInput.addEventListener("input", handleChangeImage);
      imageInput?.addEventListener("change", handleChangeImage);
      downloadButton?.addEventListener("click", handleDownload);
      addButtonChangeListener();
    }

    onSwup("visit:end", init);
  </script>
</SplitterLayout>
